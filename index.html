<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å°åŒ—101æ‰‹å‹¢äº’å‹•ç…™ç«ç§€</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Noto Sans TC', sans-serif; user-select: none; }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; z-index: 1; }
        
        /* Modified Webcam UI - Now a Canvas for Skeleton */
        #output-canvas { 
            position: absolute; 
            bottom: 20px; 
            left: 20px; 
            width: 160px; 
            height: 120px; 
            border-radius: 10px; 
            transform: scaleX(-1); /* Mirror effect */
            background-color: rgba(0, 0, 0, 0.6); 
            border: 2px solid rgba(0, 255, 255, 0.5); 
            z-index: 2; 
        }
        
        /* Hidden raw webcam video */
        #webcam { display: none; }

        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; display: flex; flex-direction: column; justify-content: center; align-items: center; }
        
        /* Time Control Slider */
        #time-controls {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.5);
            padding: 15px;
            border-radius: 10px;
            pointer-events: auto;
            color: white;
            text-align: center;
            backdrop-filter: blur(5px);
            z-index: 50;
            display: none; 
        }

        /* Finale Button (Funnel Shape) */
        #finale-btn {
            position: absolute;
            top: 100px; /* Below time controls */
            right: 20px;
            width: 50px;
            height: 50px;
            background: rgba(255, 215, 0, 0.2);
            border: 2px solid #ffd700;
            border-radius: 50%;
            cursor: pointer;
            pointer-events: auto;
            z-index: 50;
            display: none; /* Shown on start */
            transition: transform 0.2s, background 0.2s;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        #finale-btn:hover {
            background: rgba(255, 215, 0, 0.5);
            transform: scale(1.1);
        }

        #finale-btn svg {
            width: 30px;
            height: 30px;
            fill: #ffd700;
        }

        input[type=range] {
            width: 150px;
            accent-color: #00aadd;
        }

        .wish-text {
            font-size: 4rem;
            font-weight: 900;
            color: #fff;
            text-shadow: 0 0 10px #ff00de, 0 0 20px #ff00de, 0 0 40px #ff00de;
            opacity: 0;
            transition: opacity 1s ease-out, transform 5s ease-out;
            position: absolute;
            white-space: nowrap;
        }
        
        /* Finale specific text style - more colorful */
        .finale-text {
            font-size: 3.5rem;
            font-weight: 900;
            position: absolute;
            white-space: nowrap;
            animation: floatFade 4s forwards;
            text-shadow: 2px 2px 0 #000, -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000, 1px 1px 0 #000;
        }

        @keyframes floatFade {
            0% { opacity: 0; transform: scale(0.5) translateY(50px); }
            10% { opacity: 1; transform: scale(1.2) translateY(0); }
            80% { opacity: 1; transform: scale(1) translateY(-50px); }
            100% { opacity: 0; transform: scale(0.8) translateY(-100px); }
        }

        #instructions {
            position: absolute;
            top: 20px;
            left: 20px;
            color: rgba(255, 255, 255, 0.8);
            background: rgba(0, 0, 0, 0.5);
            padding: 15px;
            border-radius: 8px;
            font-size: 0.9rem;
            pointer-events: auto;
            max-width: 300px;
            display: none; 
            z-index: 50; 
        }
        
        #copyright {
            position: absolute;
            bottom: 10px;
            right: 20px;
            color: rgba(255, 255, 255, 0.4);
            font-size: 0.8rem;
            z-index: 60;
            pointer-events: none;
            font-family: monospace;
            text-shadow: 0 0 2px black;
        }
        
        #overlay-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            color: white;
            text-align: center;
            pointer-events: auto;
        }

        #loading-text {
            font-size: 1.5rem;
            margin-bottom: 20px;
        }

        #start-btn {
            padding: 15px 40px;
            font-size: 1.5rem;
            background: linear-gradient(45deg, #ff00de, #00aadd);
            border: none;
            border-radius: 50px;
            color: white;
            cursor: pointer;
            display: none; 
            font-weight: bold;
            box-shadow: 0 0 20px rgba(255, 0, 222, 0.5);
            transition: transform 0.2s;
        }

        #start-btn:hover {
            transform: scale(1.05);
        }

        #error-msg {
            color: #ff4444;
            margin-top: 20px;
            max-width: 80%;
            display: none;
        }

        #countdown {
            font-size: 12rem;
            color: #ffd700;
            font-weight: bold;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.8);
            display: none;
            z-index: 60;
        }

        #speech-bubble {
            display: none;
            background: rgba(255, 255, 255, 0.95);
            color: #333;
            padding: 20px 40px;
            border-radius: 50px;
            font-size: 1.5rem;
            font-weight: bold;
            position: relative;
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.6);
            animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            margin-bottom: 20px; 
        }
        
        #speech-bubble::after {
            content: '';
            position: absolute;
            bottom: -10px;
            left: 50%;
            transform: translateX(-50%);
            border-width: 10px 10px 0;
            border-style: solid;
            border-color: rgba(255, 255, 255, 0.95) transparent transparent transparent;
        }

        @keyframes popIn {
            0% { transform: scale(0); opacity: 0; }
            100% { transform: scale(1); opacity: 1; }
        }
    </style>
    <!-- Imports -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
                "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/+esm"
            }
        }
    </script>
</head>
<body>

    <div id="overlay-screen">
        <div id="loading-text">æ­£åœ¨è¼‰å…¥ AI æ¨¡å‹...</div>
        <button id="start-btn">é–‹å§‹é«”é©—</button>
        <div id="error-msg"></div>
        <div style="margin-top: 15px; font-size: 0.9rem; color: #aaa;">
            æ­¤é«”é©—éœ€è¦é–‹å•Ÿæ”å½±æ©Ÿèˆ‡éº¥å…‹é¢¨æ¬Šé™<br>
            (Camera & Microphone access required)
        </div>
    </div>
    
    <div id="instructions">
        <h2 class="text-xl font-bold mb-2 text-yellow-400">ğŸ® æ‰‹å‹¢äº’å‹•æŒ‡å—</h2>
        <ul class="list-disc pl-5 space-y-1">
            <li>âœŠ <b>æ¡æ‹³</b>ï¼šé›†æ°£ (å‡ºç¾å…‰é»)</li>
            <li>ğŸ–ï¸ <b>å¼µé–‹æ‰‹æŒ</b>ï¼šæ–½æ”¾ç…™ç«</li>
            <li>ğŸ‘ˆğŸ‘‰ <b>å·¦å³æŒ‡</b>ï¼šæ—‹è½‰è¦–è§’</li>
            <li>ğŸ‘†ğŸ‘‡ <b>ä¸Šä¸‹æŒ‡</b>ï¼šé«˜ä½è¦–è§’</li>
            <li>ğŸ‘Œ <b>å…©æŒ‡æåˆ/å¼µé–‹</b>ï¼šæ‹‰è¿‘/æ‹‰é </li>
            <li>âœŒï¸ <b>æ¯” YA</b>ï¼šå€’æ•¸ 3 ç§’è¨±é¡˜</li>
        </ul>
        <div id="status-msg" class="mt-2 text-green-400 font-bold">ç­‰å¾…æ‰‹å‹¢...</div>
    </div>
    
    <!-- Time Controls -->
    <div id="time-controls">
        <div class="mb-1 text-sm font-bold">â±ï¸ æ™‚é–“æµé€é€Ÿåº¦</div>
        <input type="range" id="time-speed" min="0" max="20" value="1" step="1">
        <div id="time-display" class="mt-1 text-xs text-gray-300">ç›®å‰æ™‚é–“: 18:00</div>
    </div>

    <!-- Finale Button (Funnel Icon) -->
    <div id="finale-btn" title="è·¨å¹´å€’æ•¸æ¨¡å¼ (Finale Mode)">
        <svg viewBox="0 0 24 24">
            <path d="M10,18v-6l-5-9h14l-5,9v6h-4z" />
        </svg>
    </div>

    <div id="copyright"></div>

    <div id="ui-layer">
        <div id="speech-bubble">ğŸ¤ è«‹èªªè©±...</div>
        <div id="countdown"></div>
        <div id="wish-container"></div>
    </div>

    <video id="webcam" autoplay playsinline></video>
    <canvas id="output-canvas" width="640" height="480"></canvas>
    
    <div id="canvas-container"></div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { FilesetResolver, GestureRecognizer, DrawingUtils } from '@mediapipe/tasks-vision';

        // Disable right-click context menu
        document.addEventListener('contextmenu', event => event.preventDefault());

        // --- Configuration ---
        const WEBCAM_WIDTH = 640;
        const WEBCAM_HEIGHT = 480;
        
        // ZOOM LIMITS
        const MIN_DISTANCE = 80;  
        const MAX_DISTANCE = 250; 
        
        // --- Obfuscated Copyright Protection ---
        const _0x9a2b = [169, 32, 50, 48, 50, 53, 32, 74, 121, 117, 110, 32, 72, 97, 110, 32, 67, 104, 101, 110];
        function _0x4e2d() { return String.fromCharCode(..._0x9a2b); }

        async function initCopyrightProtection() {
            const _0x1f = document.getElementById('copyright');
            if(_0x1f) _0x1f.innerText = _0x4e2d();
            setInterval(() => {
                const _el = document.getElementById('copyright');
                const _target = _0x4e2d();
                let _valid = false;
                if (_el && _el.innerText === _target && _el.style.display !== 'none' && _el.style.visibility !== 'hidden' && _el.style.opacity !== '0') {
                    _valid = true;
                }
                if (!_valid) {
                    let _new = document.getElementById('copyright');
                    if (!_new) {
                        _new = document.createElement('div');
                        _new.id = 'copyright';
                        document.body.appendChild(_new);
                    }
                    _new.innerText = _target;
                    _new.style.display = 'block';
                    _new.style.visibility = 'visible';
                    _new.style.opacity = '1';
                    _new.style.position = 'absolute';
                    _new.style.bottom = '10px';
                    _new.style.right = '20px';
                    _new.style.zIndex = '9999';
                }
            }, 1000);
        }

        // --- Globals ---
        let scene, camera, renderer, controls;
        let gestureRecognizer, drawingUtils;
        let webcamRunning = false;
        let video = document.getElementById('webcam');
        let outputCanvas = document.getElementById('output-canvas');
        let canvasCtx = outputCanvas.getContext('2d');
        
        let statusMsg = document.getElementById('status-msg');
        let speechBubble = document.getElementById('speech-bubble');
        let lastGestureTime = 0;
        let isMakingWish = false;
        let recognition; 

        // Time Cycle Globals
        let gameTime = 18.0; 
        let timeSpeed = 1.0; 
        const timeDisplay = document.getElementById('time-display');
        const speedSlider = document.getElementById('time-speed');
        
        // Finale Mode Globals
        let isFinaleMode = false;
        let finaleInterval;
        const finaleMessages = [
            "2026æ–°å¹´å¿«æ¨‚ï¼", 
            "Happy New Year", 
            "Taiwan No.1", 
            "å¤©ä½‘è‡ºç£", 
            "å¹³å®‰å–œæ¨‚", 
            "è¬äº‹å¦‚æ„"
        ];
        
        // Scene Objects
        let sunLight, moonLight, ambientLight;
        let cityWindowsMat, cityStreetLightsMat, towerGlassMat, starsPoints;

        // Audio
        let audioCtx;

        // Fireworks & Particles
        let fireworks = [];
        let particleTexture; 
        let handParticle; 

        let towerGroup;

        // --- 1. Load Resources ---
        async function loadResources() {
            try {
                initCopyrightProtection();
                setupThreeJS();
                particleTexture = getParticleTexture();
                createTaipei101();
                createCity(); 
                createStars();
                await setupGestureRecognizer();
                
                document.getElementById('loading-text').style.display = 'none';
                const startBtn = document.getElementById('start-btn');
                startBtn.style.display = 'block';
                
                speedSlider.addEventListener('input', (e) => {
                    if(!isFinaleMode) timeSpeed = parseFloat(e.target.value);
                });
                
                // Finale Button Listener
                document.getElementById('finale-btn').addEventListener('click', startFinaleMode);
                
                startBtn.addEventListener('click', startExperience);

            } catch (err) {
                console.error(err);
                showError("è¼‰å…¥å¤±æ•—: " + err.message);
            }
        }

        // --- 2. Start Experience ---
        async function startExperience() {
            const overlay = document.getElementById('overlay-screen');
            const startBtn = document.getElementById('start-btn');
            startBtn.innerText = "å•Ÿå‹•ä¸­...";
            startBtn.disabled = true;

            try {
                try {
                    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                    if(audioCtx.state === 'suspended') await audioCtx.resume();
                } catch(e) { console.warn("Web Audio API not supported"); }

                await setupWebcam();
                setupSpeech();

                overlay.style.display = 'none'; 
                document.getElementById('instructions').style.display = 'block';
                document.getElementById('time-controls').style.display = 'block';
                document.getElementById('finale-btn').style.display = 'flex'; // Show finale button
                animate();

            } catch (err) {
                console.error("Permission Error:", err);
                startBtn.innerText = "é‡è©¦";
                startBtn.disabled = false;
                if (err.name === 'NotAllowedError' || err.name === 'PermissionDeniedError') {
                    showError("âš ï¸ ç„¡æ³•å–å¾—æ¬Šé™<br>è«‹é»æ“Šç¶²å€åˆ—å·¦å´çš„è¨­å®šåœ–ç¤ºï¼Œå…è¨±ã€Œæ”å½±æ©Ÿã€èˆ‡ã€Œéº¥å…‹é¢¨ã€æ¬Šé™ï¼Œç„¶å¾Œé‡æ–°æ•´ç†é é¢ã€‚");
                } else {
                    showError("å•Ÿå‹•éŒ¯èª¤: " + err.message);
                }
            }
        }

        function showError(msg) {
            const errEl = document.getElementById('error-msg');
            errEl.innerHTML = msg;
            errEl.style.display = 'block';
            document.getElementById('loading-text').style.display = 'none';
        }

        // --- Finale Mode Logic ---
        function startFinaleMode() {
            if(isFinaleMode) return;
            isFinaleMode = true;
            
            // 1. Disable Controls & UI updates
            statusMsg.innerText = "âœ¨ è·¨å¹´å€’æ•¸æ¨¡å¼å•Ÿå‹• âœ¨";
            document.getElementById('time-controls').style.opacity = '0.5';
            document.getElementById('time-controls').style.pointerEvents = 'none';
            document.getElementById('finale-btn').style.display = 'none'; // Hide button during finale
            
            // 2. Set Time to Midnight (23:59:50) approx
            gameTime = 23.99; 
            
            // 3. Countdown
            const countdownEl = document.getElementById('countdown');
            countdownEl.style.display = 'block';
            let count = 10;
            
            const timer = setInterval(() => {
                countdownEl.innerText = count;
                playFireworkSound(); // Tick sound
                count--;
                
                if (count < 0) {
                    clearInterval(timer);
                    countdownEl.style.display = 'none';
                    launchMassiveFireworks();
                }
            }, 1000);
        }

        function launchMassiveFireworks() {
            const duration = 20000; // 20 seconds of show
            const startTime = Date.now();
            
            // Loop for fireworks
            finaleInterval = setInterval(() => {
                // Random position high up
                const x = (Math.random() - 0.5) * 150;
                const y = 50 + Math.random() * 80;
                const z = (Math.random() - 0.5) * 150;
                // Random vivid colors
                const color = new THREE.Color().setHSL(Math.random(), 1.0, 0.6).getHex();
                
                createFirework(x, y, z, color);
                
                // Chance to spawn text
                if(Math.random() > 0.7) {
                    spawnFinaleText();
                }
                
                if (Date.now() - startTime > duration) {
                    endFinaleMode();
                }
            }, 200); // 5 fireworks per second
        }

        function spawnFinaleText() {
            const container = document.getElementById('wish-container');
            const el = document.createElement('div');
            el.className = 'finale-text';
            const text = finaleMessages[Math.floor(Math.random() * finaleMessages.length)];
            el.innerText = text;
            
            // Random color
            const hue = Math.floor(Math.random() * 360);
            el.style.color = `hsl(${hue}, 100%, 70%)`;
            
            // Random screen position (avoiding very edges)
            const left = 10 + Math.random() * 80;
            const top = 20 + Math.random() * 60;
            el.style.left = `${left}%`;
            el.style.top = `${top}%`;
            
            container.appendChild(el);
            
            // Remove after anim
            setTimeout(() => {
                el.remove();
            }, 4000);
        }

        function endFinaleMode() {
            clearInterval(finaleInterval);
            isFinaleMode = false;
            
            statusMsg.innerText = "ç­‰å¾…æ‰‹å‹¢...";
            document.getElementById('time-controls').style.opacity = '1';
            document.getElementById('time-controls').style.pointerEvents = 'auto';
            document.getElementById('finale-btn').style.display = 'flex';
            
            // Restore time speed from slider
            timeSpeed = parseFloat(speedSlider.value);
        }

        // --- Helper: Texture ---
        function getParticleTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 32; canvas.height = 32;
            const ctx = canvas.getContext('2d');
            const gradient = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
            gradient.addColorStop(0, 'rgba(255,255,255,1)');
            gradient.addColorStop(0.2, 'rgba(255,255,255,0.8)');
            gradient.addColorStop(0.5, 'rgba(255,255,255,0.2)');
            gradient.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 32, 32);
            return new THREE.CanvasTexture(canvas);
        }

        // --- Helper: Windows ---
        function getWindowTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#000'; ctx.fillRect(0,0,64,64);
            ctx.fillStyle = '#ffecaa'; 
            for(let i=0; i<32; i++) {
                if(Math.random() > 0.4) {
                    const x = Math.floor(Math.random()*8)*8;
                    const y = Math.floor(Math.random()*16)*4;
                    ctx.fillRect(x+1, y+1, 5, 2); 
                }
            }
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.magFilter = THREE.NearestFilter; 
            return texture;
        }

        // --- Three.js Setup ---
        function setupThreeJS() {
            const container = document.getElementById('canvas-container');
            
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000); 
            scene.fog = new THREE.FogExp2(0x101015, 0.003); 

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 40, 160);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.toneMapping = THREE.ReinhardToneMapping;
            container.appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.autoRotate = false;
            controls.maxPolarAngle = Math.PI / 2 - 0.05; 
            controls.minDistance = MIN_DISTANCE;
            controls.maxDistance = MAX_DISTANCE;
            controls.enableZoom = false; 
            controls.target.set(0, 40, 0);

            ambientLight = new THREE.AmbientLight(0x222233, 0.5); 
            scene.add(ambientLight);

            sunLight = new THREE.DirectionalLight(0xffffee, 0); 
            sunLight.position.set(100, 100, 50);
            scene.add(sunLight);

            moonLight = new THREE.DirectionalLight(0xaaccff, 0.5); 
            moonLight.position.set(-50, 100, -50);
            scene.add(moonLight);

            const planeGeo = new THREE.PlaneGeometry(800, 800);
            const planeMat = new THREE.MeshStandardMaterial({ 
                color: 0x1a1a1a, roughness: 0.8, metalness: 0.2 
            });
            const plane = new THREE.Mesh(planeGeo, planeMat);
            plane.rotation.x = -Math.PI / 2;
            scene.add(plane);

            const sphereGeo = new THREE.SphereGeometry(1, 16, 16);
            const sphereMat = new THREE.MeshBasicMaterial({ color: 0xffaa00 });
            handParticle = new THREE.Mesh(sphereGeo, sphereMat);
            handParticle.visible = false;
            scene.add(handParticle);

            window.addEventListener('resize', onWindowResize);
        }

        // --- Day/Night Cycle ---
        function updateDayNightCycle(deltaTime) {
            // Skip update if finale mode
            if(isFinaleMode) {
                // Force Night look
                scene.background.setHex(0x050510);
                scene.fog.color.setHex(0x050510);
                sunLight.intensity = 0;
                moonLight.intensity = 0.8;
                ambientLight.intensity = 0.2;
                if(cityWindowsMat) cityWindowsMat.emissiveIntensity = 0.8;
                if(cityStreetLightsMat) cityStreetLightsMat.color.setHex(0xffddaa);
                if(towerGlassMat) towerGlassMat.emissiveIntensity = 1.0;
                if(starsPoints) starsPoints.material.opacity = 1.0;
                return;
            }

            gameTime += (deltaTime * timeSpeed * 0.5); 
            if (gameTime >= 24) gameTime = 0;

            const h = Math.floor(gameTime);
            const m = Math.floor((gameTime - h) * 60);
            timeDisplay.innerText = `ç›®å‰æ™‚é–“: ${h.toString().padStart(2,'0')}:${m.toString().padStart(2,'0')}`;
            
            let isNight = false;
            let sunIntensity = 0;
            let moonIntensity = 0;
            let skyColor = new THREE.Color(0x000000);
            let cityLightsOn = false;

            if (gameTime >= 6 && gameTime < 18) {
                isNight = false;
                if (gameTime < 7) { 
                    const t = gameTime - 6;
                    sunIntensity = t;
                    moonIntensity = 0.5 * (1-t);
                    skyColor.lerpColors(new THREE.Color(0x050510), new THREE.Color(0x87CEEB), t); 
                } else if (gameTime > 17) { 
                    const t = gameTime - 17;
                    sunIntensity = 1 - t;
                    moonIntensity = 0.5 * t;
                    skyColor.lerpColors(new THREE.Color(0x87CEEB), new THREE.Color(0xff4500), t); 
                } else {
                    sunIntensity = 1;
                    moonIntensity = 0;
                    skyColor.setHex(0x87CEEB); 
                }
            } else {
                isNight = true;
                sunIntensity = 0;
                if (gameTime >= 18 && gameTime < 19) { 
                    const t = gameTime - 18;
                    moonIntensity = 0.5 * t;
                    skyColor.lerpColors(new THREE.Color(0xff4500), new THREE.Color(0x050510), t); 
                } else if (gameTime >= 5 && gameTime < 6) { 
                    const t = gameTime - 5;
                    moonIntensity = 0.5 * (1-t);
                    skyColor.lerpColors(new THREE.Color(0x050510), new THREE.Color(0x101030), t);
                } else {
                    moonIntensity = 0.5;
                    skyColor.setHex(0x050510);
                }
                cityLightsOn = true;
            }

            scene.background = skyColor;
            scene.fog.color.copy(skyColor).multiplyScalar(0.5); 
            
            sunLight.intensity = sunIntensity * 1.5;
            moonLight.intensity = moonIntensity;
            ambientLight.intensity = 0.2 + sunIntensity * 0.6; 

            const sunAngle = ((gameTime - 6) / 24) * Math.PI * 2; 
            sunLight.position.set(Math.cos(sunAngle)*100, Math.sin(sunAngle)*100, 50);

            if (cityWindowsMat) {
                const targetEmit = cityLightsOn ? 0.8 : 0.0;
                cityWindowsMat.emissiveIntensity += (targetEmit - cityWindowsMat.emissiveIntensity) * 0.05;
            }
            if (cityStreetLightsMat) {
                const targetColor = cityLightsOn ? new THREE.Color(0xffddaa) : new THREE.Color(0x222222);
                cityStreetLightsMat.color.lerp(targetColor, 0.05);
            }
            if (towerGlassMat) {
                const targetEmit = cityLightsOn ? 1.0 : 0.0; 
                towerGlassMat.emissiveIntensity += (targetEmit - towerGlassMat.emissiveIntensity) * 0.05;
            }
            if (starsPoints) {
                const targetOp = isNight ? 1.0 : 0.0;
                starsPoints.material.opacity += (targetOp - starsPoints.material.opacity) * 0.05;
            }
        }

        // --- Procedural City ---
        function createCity() {
            const cityGroup = new THREE.Group();
            const buildingGeo = new THREE.BoxGeometry(1, 1, 1);
            const windowTex = getWindowTexture();
            
            cityWindowsMat = new THREE.MeshStandardMaterial({
                color: 0x222222, map: windowTex, roughness: 0.2, emissive: 0xffaa00, emissiveMap: windowTex, emissiveIntensity: 0.8
            });
            const matDark = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.5 });
            const matGlass = new THREE.MeshStandardMaterial({ color: 0x223344, roughness: 0.1, metalness: 0.6 });

            const range = 250; const blockSize = 30;
            
            for (let x = -range; x <= range; x += blockSize) {
                for (let z = -range; z <= range; z += blockSize) {
                    const dist = Math.sqrt(x*x + z*z);
                    if (dist < 45) continue; 
                    if (Math.random() > 0.2) {
                        const height = 15 + Math.random() * 50; 
                        const width = 10 + Math.random() * 15;
                        const depth = 10 + Math.random() * 15;
                        const mesh = new THREE.Mesh(buildingGeo, Math.random()>0.3 ? cityWindowsMat : matGlass);
                        mesh.position.set(x + (Math.random()-0.5)*5, height/2, z + (Math.random()-0.5)*5);
                        mesh.scale.set(width, height, depth);
                        cityGroup.add(mesh);
                        const roof = new THREE.Mesh(buildingGeo, matDark);
                        roof.position.set(mesh.position.x, height + 1, mesh.position.z);
                        roof.scale.set(width*0.8, 2, depth*0.8);
                        cityGroup.add(roof);
                    }
                }
            }

            const treeGroup = new THREE.Group();
            const trunkGeo = new THREE.CylinderGeometry(0.5, 0.7, 3, 5);
            const trunkMat = new THREE.MeshStandardMaterial({ color: 0x443322 });
            const leavesGeo = new THREE.IcosahedronGeometry(2.5, 0);
            const leavesMat = new THREE.MeshStandardMaterial({ color: 0x225522, roughness: 0.9 });
            const poleGeo = new THREE.CylinderGeometry(0.2, 0.2, 8);
            const poleMat = new THREE.MeshStandardMaterial({ color: 0x333333 });
            const lightGeo = new THREE.SphereGeometry(0.8);
            cityStreetLightsMat = new THREE.MeshBasicMaterial({ color: 0xffddaa });

            for (let i = 0; i < 150; i++) {
                const r = 50 + Math.random() * 200;
                const theta = Math.random() * Math.PI * 2;
                const px = r * Math.cos(theta);
                const pz = r * Math.sin(theta);
                if (Math.random() > 0.4) {
                    const trunk = new THREE.Mesh(trunkGeo, trunkMat);
                    trunk.position.set(px, 1.5, pz);
                    treeGroup.add(trunk);
                    const leaves = new THREE.Mesh(leavesGeo, leavesMat);
                    leaves.position.set(px, 4, pz);
                    treeGroup.add(leaves);
                } else {
                    const pole = new THREE.Mesh(poleGeo, poleMat);
                    pole.position.set(px, 4, pz);
                    treeGroup.add(pole);
                    const light = new THREE.Mesh(lightGeo, cityStreetLightsMat);
                    light.position.set(px, 8, pz);
                    treeGroup.add(light);
                }
            }
            scene.add(cityGroup);
            scene.add(treeGroup);
        }

        function createTaipei101() {
            towerGroup = new THREE.Group();
            towerGlassMat = new THREE.MeshPhysicalMaterial({
                color: 0x00aadd, metalness: 0.2, roughness: 0.1, transmission: 0.6, thickness: 2, emissive: 0x004466, emissiveIntensity: 1.0 
            });
            const goldMaterial = new THREE.MeshStandardMaterial({ color: 0xffd700, metalness: 0.8, roughness: 0.2 });
            const baseGeo = new THREE.BoxGeometry(20, 15, 20);
            const base = new THREE.Mesh(baseGeo, towerGlassMat);
            base.position.y = 7.5;
            towerGroup.add(base);
            const segmentCount = 8; const startY = 15; const segmentHeight = 8;
            for(let i=0; i<segmentCount; i++) {
                const yPos = startY + i * segmentHeight;
                const segmentGeo = new THREE.CylinderGeometry(11 - (i*0.2), 9 - (i*0.2), segmentHeight, 4);
                segmentGeo.rotateY(Math.PI/4); 
                const segment = new THREE.Mesh(segmentGeo, towerGlassMat);
                segment.position.y = yPos + segmentHeight/2;
                towerGroup.add(segment);
                if (i < segmentCount) {
                    for(let c=0; c<4; c++) {
                        const cornerGeo = new THREE.BoxGeometry(1,1,1);
                        const corner = new THREE.Mesh(cornerGeo, goldMaterial);
                        const angle = (Math.PI/2) * c;
                        const radius = 8 - (i*0.2);
                        corner.position.set(Math.cos(angle)*radius*1.2, yPos + segmentHeight, Math.sin(angle)*radius*1.2);
                        towerGroup.add(corner);
                    }
                }
            }
            const spireHeight = 15;
            const spireGeo = new THREE.CylinderGeometry(0.5, 3, spireHeight, 8);
            const spire = new THREE.Mesh(spireGeo, towerGlassMat);
            spire.position.y = startY + (segmentCount * segmentHeight) + spireHeight/2;
            towerGroup.add(spire);
            scene.add(towerGroup);
        }

        function createStars() {
            const starGeo = new THREE.BufferGeometry();
            const starCount = 1000;
            const posArray = new Float32Array(starCount * 3);
            for(let i=0; i<starCount*3; i++) posArray[i] = (Math.random() - 0.5) * 500;
            starGeo.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
            const starMat = new THREE.PointsMaterial({
                size: 1.5, color: 0xffffff, map: particleTexture, transparent: true, opacity: 1.0, alphaTest: 0.1
            });
            starsPoints = new THREE.Points(starGeo, starMat);
            starsPoints.position.y = 100;
            scene.add(starsPoints);
        }

        // --- MediaPipe & Webcam ---
        async function setupGestureRecognizer() {
            const vision = await FilesetResolver.forVisionTasks(
                "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm"
            );
            gestureRecognizer = await GestureRecognizer.createFromOptions(vision, {
                baseOptions: {
                    modelAssetPath: "https://storage.googleapis.com/mediapipe-models/gesture_recognizer/gesture_recognizer/float16/1/gesture_recognizer.task",
                    delegate: "GPU"
                },
                runningMode: "VIDEO",
                numHands: 1 
            });
            drawingUtils = new DrawingUtils(canvasCtx);
        }

        async function setupWebcam() {
            const constraints = { video: { width: WEBCAM_WIDTH, height: WEBCAM_HEIGHT } };
            const stream = await navigator.mediaDevices.getUserMedia(constraints);
            video.srcObject = stream;
            return new Promise((resolve) => {
                video.onloadeddata = () => { webcamRunning = true; resolve(); };
            });
        }

        function setupSpeech() {
            if ('webkitSpeechRecognition' in window) {
                recognition = new webkitSpeechRecognition();
                recognition.continuous = false;
                recognition.interimResults = false;
                recognition.lang = 'zh-TW';
                recognition.onstart = () => { statusMsg.innerText = "ğŸ¤ è«‹èªªå‡ºä½ çš„é¡˜æœ›ï¼"; speechBubble.innerText = "è«‹èªªå‡ºä½ çš„é¡˜æœ›..."; speechBubble.style.display = 'block'; };
                recognition.onresult = (event) => { showWish(event.results[0][0].transcript); speechBubble.style.display = 'none'; };
                recognition.onerror = () => { statusMsg.innerText = "èªéŸ³è¾¨è­˜éŒ¯èª¤ï¼Œè«‹é‡è©¦"; speechBubble.style.display = 'none'; resetWishState(); };
                recognition.onend = () => { if(isMakingWish) setTimeout(resetWishState, 5000); };
            }
        }

        // --- Interaction Logic ---
        function get3DHandPosition(x, y) {
            const vec = new THREE.Vector3();
            const pos = new THREE.Vector3();
            vec.set((1 - x) * 2 - 1, - (y * 2 - 1), 0.5);
            vec.unproject(camera);
            vec.sub(camera.position).normalize();
            pos.copy(camera.position).add(vec.multiplyScalar(40));
            return pos;
        }

        function playFireworkSound() {
            if (!audioCtx) return;
            if (audioCtx.state === 'suspended') audioCtx.resume().catch(e=>console.log(e));
            const t = audioCtx.currentTime;
            const buffer = audioCtx.createBuffer(1, audioCtx.sampleRate * 2, audioCtx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < buffer.length; i++) data[i] = Math.random() * 2 - 1;
            
            const noise = audioCtx.createBufferSource();
            noise.buffer = buffer;
            const filter = audioCtx.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.setValueAtTime(1000, t);
            filter.frequency.exponentialRampToValueAtTime(100, t + 0.5);
            const gain = audioCtx.createGain();
            gain.gain.setValueAtTime(1, t);
            gain.gain.exponentialRampToValueAtTime(0.01, t + 0.5);
            
            noise.connect(filter); filter.connect(gain); gain.connect(audioCtx.destination);
            noise.start(t); noise.stop(t+0.5);
        }

        function dist(a, b) { return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2)); }

        async function predictWebcam() {
            // IF FINALE MODE, SKIP HAND INTERACTION
            if(isFinaleMode) {
                canvasCtx.clearRect(0, 0, outputCanvas.width, outputCanvas.height); // Clear skeleton
                handParticle.visible = false;
                return;
            }

            let nowInMs = Date.now();
            const results = gestureRecognizer.recognizeForVideo(video, nowInMs);
            canvasCtx.clearRect(0, 0, outputCanvas.width, outputCanvas.height);

            if (results.landmarks && results.landmarks.length > 0) {
                for (const landmarks of results.landmarks) {
                    drawingUtils.drawConnectors(landmarks, GestureRecognizer.HAND_CONNECTIONS, { color: "#00FF00", lineWidth: 3 });
                    drawingUtils.drawLandmarks(landmarks, { color: "#FF0000", lineWidth: 1, radius: 3 });
                }

                if (results.gestures.length > 0) {
                    const gesture = results.gestures[0][0];
                    const categoryName = gesture.categoryName;
                    const landmarks = results.landmarks[0]; 
                    const palmX = (landmarks[0].x + landmarks[9].x) / 2;
                    const palmY = (landmarks[0].y + landmarks[9].y) / 2;
                    
                    handPos3D = get3DHandPosition(palmX, palmY);
                    handParticle.position.copy(handPos3D);
                    handParticle.visible = true;

                    const handSize = dist(landmarks[0], landmarks[9]);
                    const pinchRatio = dist(landmarks[4], landmarks[8]) / handSize;
                    const idxDx = landmarks[8].x - landmarks[5].x; 
                    const idxDy = landmarks[8].y - landmarks[5].y; 
                    
                    let isZooming = false; let isRotating = false;

                    if (categoryName === "Victory") {
                        handParticle.material.color.setHex(0xffff00);
                        statusMsg.innerText = "âœŒï¸ æº–å‚™è¨±é¡˜...";
                        handClosed = false;
                        triggerWishSequence();
                    } else {
                        const currentDist = camera.position.distanceTo(controls.target);
                        if (pinchRatio < 0.15) {
                            if (currentDist > MIN_DISTANCE) {
                                statusMsg.innerText = "ğŸ‘Œ è¦–è§’æ‹‰è¿‘";
                                handParticle.material.color.setHex(0x00ffff);
                                const dir = new THREE.Vector3();
                                camera.getWorldDirection(dir);
                                camera.position.addScaledVector(dir, 0.5);
                                isZooming = true;
                            }
                        } else if (pinchRatio > 0.8 && categoryName !== "Open_Palm") {
                            if (currentDist < MAX_DISTANCE) {
                                statusMsg.innerText = "ğŸ‘ è¦–è§’æ‹‰é ";
                                handParticle.material.color.setHex(0x0000ff);
                                const dir = new THREE.Vector3();
                                camera.getWorldDirection(dir);
                                camera.position.addScaledVector(dir, -0.5);
                                isZooming = true;
                            }
                        }

                        if (!isZooming) {
                            const isIndexExtended = dist(landmarks[5], landmarks[8]) > handSize * 0.5;
                            if (isIndexExtended && categoryName !== "Open_Palm" && categoryName !== "Closed_Fist") {
                                const sensitivity = 0.03;
                                let hasMovement = false;
                                if (idxDx < -0.05) { controls.autoRotate = false; camera.position.applyAxisAngle(new THREE.Vector3(0,1,0), sensitivity); hasMovement = true; } 
                                else if (idxDx > 0.05) { controls.autoRotate = false; camera.position.applyAxisAngle(new THREE.Vector3(0,1,0), -sensitivity); hasMovement = true; }
                                if (idxDy < -0.05) { camera.position.y += 0.5; hasMovement = true; } 
                                else if (idxDy > 0.05) { camera.position.y -= 0.5; if(camera.position.y < 5) camera.position.y = 5; hasMovement = true; }
                                if (hasMovement) { statusMsg.innerText = "èª¿æ•´è¦–è§’ä¸­"; camera.lookAt(0, 40, 0); isRotating = true; }
                            }
                            
                            if (!isRotating) {
                                if (categoryName === "Closed_Fist") {
                                    statusMsg.innerText = "âœŠ é›†æ°£ä¸­...";
                                    handParticle.material.color.setHex(0xff0000);
                                    handClosed = true; 
                                    handParticle.scale.setScalar(1.5 + Math.sin(nowInMs * 0.02) * 0.5);
                                } else if (categoryName === "Open_Palm") {
                                    statusMsg.innerText = "ğŸ–ï¸ æ–½æ”¾ç…™ç«ï¼";
                                    handParticle.material.color.setHex(0xffffff);
                                    handParticle.scale.setScalar(1);
                                    if (handClosed) { createFirework(handPos3D.x, handPos3D.y, handPos3D.z); playFireworkSound(); handClosed = false; }
                                } else {
                                    statusMsg.innerText = "ç­‰å¾…æ‰‹å‹¢...";
                                    handParticle.scale.setScalar(1);
                                }
                            }
                        }
                    }
                    previousCategoryName = categoryName;
                }
            } else {
                handParticle.visible = false;
            }
        }

        // --- Core Firework Logic ---
        function createFirework(x, y, z, forceColor = null) {
            const particleCount = 400 + Math.random() * 200;
            const geo = new THREE.BufferGeometry();
            const pos = []; const vel = []; const col = [];
            const baseC = new THREE.Color();
            if (forceColor) baseC.setHex(forceColor); else baseC.setHSL(Math.random(), 1.0, 0.6); 

            for (let i = 0; i < particleCount; i++) {
                pos.push(x, y, z);
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos((Math.random() * 2) - 1);
                const spd = 0.2 + Math.random() * 2.5; 
                vel.push(spd * Math.sin(phi) * Math.cos(theta), spd * Math.sin(phi) * Math.sin(theta), spd * Math.cos(phi));
                const pC = baseC.clone(); pC.offsetHSL(0, 0, (Math.random()-0.5)*0.4);
                col.push(pC.r, pC.g, pC.b);
            }
            geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
            geo.setAttribute('color', new THREE.Float32BufferAttribute(col, 3));
            const mat = new THREE.PointsMaterial({ size: 2.5, map: particleTexture, vertexColors: true, blending: THREE.AdditiveBlending, depthWrite: false, transparent: true, opacity: 1.0 });
            const pts = new THREE.Points(geo, mat);
            scene.add(pts);
            if(forceColor) playFireworkSound();
            fireworks.push({ mesh: pts, velocities: vel, age: 0, maxAge: 80 + Math.random() * 40 });
        }

        function updateFireworks() {
            for (let i = fireworks.length - 1; i >= 0; i--) {
                const fw = fireworks[i]; fw.age++;
                const pos = fw.mesh.geometry.attributes.position.array;
                for (let j = 0; j < fw.velocities.length / 3; j++) {
                    pos[j*3] += fw.velocities[j*3];
                    pos[j*3+1] += fw.velocities[j*3+1];
                    pos[j*3+2] += fw.velocities[j*3+2];
                    fw.velocities[j*3+1] -= 0.015; 
                    fw.velocities[j*3] *= 0.96; fw.velocities[j*3+1] *= 0.96; fw.velocities[j*3+2] *= 0.96;
                }
                fw.mesh.geometry.attributes.position.needsUpdate = true;
                const life = fw.age / fw.maxAge;
                fw.mesh.material.opacity = 1 - Math.pow(life, 3);
                if (fw.age >= fw.maxAge) { scene.remove(fw.mesh); fw.mesh.geometry.dispose(); fw.mesh.material.dispose(); fireworks.splice(i, 1); }
            }
        }

        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);
            const dt = clock.getDelta();
            updateDayNightCycle(dt);
            if (webcamRunning && gestureRecognizer) predictWebcam();
            controls.update();
            updateFireworks();
            if(towerGroup && towerGlassMat.emissiveIntensity > 0.3) {
               // Tower slight pulse if night logic allows
            }
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        loadResources();
    </script>
</body>
</html>