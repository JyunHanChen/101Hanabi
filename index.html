<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å°åŒ—101æ‰‹å‹¢äº’å‹•ç…™ç«ç§€</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Noto Sans TC', sans-serif; user-select: none; }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; z-index: 1; }
        
        /* Modified Webcam UI - Now a Canvas for Skeleton */
        #output-canvas { 
            position: absolute; 
            bottom: 20px; 
            left: 20px; 
            width: 160px; 
            height: 120px; 
            border-radius: 10px; 
            transform: scaleX(-1); /* Mirror effect */
            background-color: rgba(0, 0, 0, 0.6); 
            border: 2px solid rgba(0, 255, 255, 0.5); 
            z-index: 2; 
        }
        
        /* Hidden raw webcam video */
        #webcam { display: none; }

        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; display: flex; flex-direction: column; justify-content: center; align-items: center; }
        
        /* Time Control Slider */
        #time-controls {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.5);
            padding: 15px;
            border-radius: 10px;
            pointer-events: auto;
            color: white;
            text-align: center;
            backdrop-filter: blur(5px);
            z-index: 50; /* Ensure visibility on top */
            display: none; /* Initially hidden, shown on start */
            transition: opacity 0.5s;
        }

        /* Finale Button (Funnel Shape) */
        #finale-btn {
            position: absolute;
            top: 100px; /* Below time controls */
            right: 20px;
            width: 50px;
            height: 50px;
            background: rgba(255, 215, 0, 0.2);
            border: 2px solid #ffd700;
            border-radius: 50%;
            cursor: pointer;
            pointer-events: auto;
            z-index: 50;
            display: none; /* Shown on start */
            transition: transform 0.2s, background 0.2s, opacity 0.5s;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        #finale-btn:hover {
            background: rgba(255, 215, 0, 0.5);
            transform: scale(1.1);
        }

        #finale-btn svg {
            width: 30px;
            height: 30px;
            fill: #ffd700;
        }

        input[type=range] {
            width: 150px;
            accent-color: #00aadd;
        }

        .wish-text {
            font-size: 4rem;
            font-weight: 900;
            color: #fff;
            text-shadow: 0 0 10px #ff00de, 0 0 20px #ff00de, 0 0 40px #ff00de;
            opacity: 0;
            transition: opacity 1s ease-out, transform 5s ease-out;
            position: absolute;
            white-space: nowrap;
        }

        /* Finale specific text style - more colorful */
        .finale-text {
            font-size: 3.5rem;
            font-weight: 900;
            position: absolute;
            white-space: nowrap;
            animation: floatFade 4s forwards;
            text-shadow: 2px 2px 0 #000, -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000, 1px 1px 0 #000;
            pointer-events: none;
        }

        @keyframes floatFade {
            0% { opacity: 0; transform: scale(0.5) translateY(50px); }
            10% { opacity: 1; transform: scale(1.2) translateY(0); }
            80% { opacity: 1; transform: scale(1) translateY(-50px); }
            100% { opacity: 0; transform: scale(0.8) translateY(-100px); }
        }

        #instructions {
            position: absolute;
            top: 20px;
            left: 20px;
            color: rgba(255, 255, 255, 0.8);
            background: rgba(0, 0, 0, 0.5);
            padding: 15px;
            border-radius: 8px;
            font-size: 0.9rem;
            pointer-events: auto;
            max-width: 300px;
            display: none; /* Initially hidden */
            z-index: 50; /* Ensure visibility on top */
        }
        
        /* Copyright Style */
        #copyright {
            position: absolute;
            bottom: 10px;
            right: 20px;
            color: rgba(255, 255, 255, 0.4);
            font-size: 0.8rem;
            z-index: 60;
            pointer-events: none;
            font-family: monospace;
            text-shadow: 0 0 2px black;
        }
        
        /* Loading & Start Screen Overlay */
        #overlay-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            color: white;
            text-align: center;
            pointer-events: auto;
        }

        #loading-text {
            font-size: 1.5rem;
            margin-bottom: 20px;
        }

        #start-btn {
            padding: 15px 40px;
            font-size: 1.5rem;
            background: linear-gradient(45deg, #ff00de, #00aadd);
            border: none;
            border-radius: 50px;
            color: white;
            cursor: pointer;
            display: none; /* Hidden until loaded */
            font-weight: bold;
            box-shadow: 0 0 20px rgba(255, 0, 222, 0.5);
            transition: transform 0.2s;
        }

        #start-btn:hover {
            transform: scale(1.05);
        }

        #error-msg {
            color: #ff4444;
            margin-top: 20px;
            max-width: 80%;
            display: none;
        }

        #countdown {
            font-size: 12rem; /* Bigger for Finale */
            color: #ffd700;
            font-weight: bold;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.8);
            display: none;
            z-index: 100;
        }

        /* New Speech Bubble Style */
        #speech-bubble {
            display: none;
            background: rgba(255, 255, 255, 0.95);
            color: #333;
            padding: 20px 40px;
            border-radius: 50px;
            font-size: 1.5rem;
            font-weight: bold;
            position: relative;
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.6);
            animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            margin-bottom: 20px; /* Space from center if needed */
        }
        
        /* Triangle for speech bubble */
        #speech-bubble::after {
            content: '';
            position: absolute;
            bottom: -10px;
            left: 50%;
            transform: translateX(-50%);
            border-width: 10px 10px 0;
            border-style: solid;
            border-color: rgba(255, 255, 255, 0.95) transparent transparent transparent;
        }

        @keyframes popIn {
            0% { transform: scale(0); opacity: 0; }
            100% { transform: scale(1); opacity: 1; }
        }

        .float-anim {
            animation: floatUp 8s forwards;
        }

        @keyframes floatUp {
            0% { opacity: 0; transform: translateY(20px) scale(0.8); }
            10% { opacity: 1; transform: translateY(0) scale(1); }
            100% { opacity: 0; transform: translateY(-150px) scale(1.1); }
        }
    </style>
    <!-- Imports -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
                "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/+esm"
            }
        }
    </script>
</head>
<body>

    <!-- Overlay for Loading / Start / Error -->
    <div id="overlay-screen">
        <div id="loading-text">æ­£åœ¨è¼‰å…¥ AI æ¨¡å‹...</div>
        <button id="start-btn">é–‹å§‹é«”é©—</button>
        <div id="error-msg"></div>
        <div style="margin-top: 15px; font-size: 0.9rem; color: #aaa;">
            æ­¤é«”é©—éœ€è¦é–‹å•Ÿæ”å½±æ©Ÿèˆ‡éº¥å…‹é¢¨æ¬Šé™<br>
            (Camera & Microphone access required)
        </div>
    </div>
    
    <div id="instructions">
        <h2 class="text-xl font-bold mb-2 text-yellow-400">ğŸ® æ‰‹å‹¢äº’å‹•æŒ‡å—</h2>
        <ul class="list-disc pl-5 space-y-1">
            <li>âœŠ <b>æ¡æ‹³</b>ï¼šé›†æ°£ (å‡ºç¾å…‰é»)</li>
            <li>ğŸ–ï¸ <b>å¼µé–‹æ‰‹æŒ</b>ï¼šæ–½æ”¾ç…™ç«</li>
            <li>ğŸ‘ˆğŸ‘‰ <b>å·¦å³æŒ‡</b>ï¼šæ—‹è½‰è¦–è§’</li>
            <li>ğŸ‘†ğŸ‘‡ <b>ä¸Šä¸‹æŒ‡</b>ï¼šé«˜ä½è¦–è§’</li>
            <li>ğŸ‘Œ <b>å…©æŒ‡æåˆ/å¼µé–‹</b>ï¼šæ‹‰è¿‘/æ‹‰é </li>
            <li>âœŒï¸ <b>æ¯” YA</b>ï¼šå€’æ•¸ 3 ç§’è¨±é¡˜</li>
        </ul>
        <div id="status-msg" class="mt-2 text-green-400 font-bold">ç­‰å¾…æ‰‹å‹¢...</div>
    </div>
    
    <!-- Time Controls -->
    <div id="time-controls">
        <div class="mb-1 text-sm font-bold">â±ï¸ æ™‚é–“æµé€é€Ÿåº¦</div>
        <input type="range" id="time-speed" min="0" max="20" value="1" step="1">
        <div id="time-display" class="mt-1 text-xs text-gray-300">ç›®å‰æ™‚é–“: 18:00</div>
    </div>

    <!-- Finale Button (Funnel Icon) -->
    <div id="finale-btn" title="è·¨å¹´å€’æ•¸æ¨¡å¼ (Finale Mode)">
        <svg viewBox="0 0 24 24">
            <path d="M10,18v-6l-5-9h14l-5,9v6h-4z" />
        </svg>
    </div>

    <!-- Copyright Notice -->
    <div id="copyright"></div>

    <div id="ui-layer">
        <div id="speech-bubble">ğŸ¤ è«‹èªªè©±...</div>
        <div id="countdown"></div>
        <div id="wish-container"></div>
    </div>

    <!-- Hidden Video, Visible Canvas for Landmarks -->
    <video id="webcam" autoplay playsinline></video>
    <canvas id="output-canvas" width="640" height="480"></canvas>
    
    <div id="canvas-container"></div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { FilesetResolver, GestureRecognizer, DrawingUtils } from '@mediapipe/tasks-vision';

        // Disable right-click context menu
        document.addEventListener('contextmenu', event => event.preventDefault());

        // --- Configuration ---
        const WEBCAM_WIDTH = 640;
        const WEBCAM_HEIGHT = 480;
        
        // ZOOM LIMITS
        const MIN_DISTANCE = 80;  // Close to tower
        const MAX_DISTANCE = 250; 
        
        // --- Obfuscated Copyright Protection ---
        // Hidden string: "Â© 2025 Jyun Han Chen"
        const _0x9a2b = [169, 32, 50, 48, 50, 53, 32, 74, 121, 117, 110, 32, 72, 97, 110, 32, 67, 104, 101, 110];
        
        function _0x4e2d() {
            return String.fromCharCode(..._0x9a2b);
        }

        async function initCopyrightProtection() {
            const _0x1f = document.getElementById('copyright');
            if(_0x1f) _0x1f.innerText = _0x4e2d();

            // Self-repair check loop
            setInterval(() => {
                const _el = document.getElementById('copyright');
                const _target = _0x4e2d();
                let _valid = false;
                
                if (_el) {
                    // Check if text matches and is visible
                    if (_el.innerText === _target && 
                        _el.style.display !== 'none' && 
                        _el.style.visibility !== 'hidden' && 
                        _el.style.opacity !== '0') {
                        _valid = true;
                    }
                }

                if (!_valid) {
                    // Restore if tampered
                    let _new = document.getElementById('copyright');
                    if (!_new) {
                        _new = document.createElement('div');
                        _new.id = 'copyright';
                        document.body.appendChild(_new);
                    }
                    _new.innerText = _target;
                    _new.style.display = 'block';
                    _new.style.visibility = 'visible';
                    _new.style.opacity = '1';
                    // Optional: Reset style if user tried to move it off screen
                    _new.style.position = 'absolute';
                    _new.style.bottom = '10px';
                    _new.style.right = '20px';
                    _new.style.zIndex = '9999';
                }
            }, 1000);
        }

        // --- Globals ---
        let scene, camera, renderer, controls;
        let gestureRecognizer, drawingUtils;
        let webcamRunning = false;
        let video = document.getElementById('webcam');
        let outputCanvas = document.getElementById('output-canvas');
        let canvasCtx = outputCanvas.getContext('2d');
        
        let statusMsg = document.getElementById('status-msg');
        let speechBubble = document.getElementById('speech-bubble');
        let lastGestureTime = 0;
        let isMakingWish = false;
        let recognition; // Speech API

        // Time Cycle Globals
        let gameTime = 18.0; // Start at 18:00 (Sunset/Night start)
        let timeSpeed = 1.0; // Multiplier
        const timeDisplay = document.getElementById('time-display');
        const speedSlider = document.getElementById('time-speed');
        
        // Finale Mode Globals
        let isFinaleMode = false;
        let finaleInterval;
        const finaleMessages = [
            "2026æ–°å¹´å¿«æ¨‚ï¼", 
            "Happy New Year", 
            "Taiwan No.1", 
            "å¤©ä½‘è‡ºç£", 
            "å¹³å®‰å–œæ¨‚", 
            "è¬äº‹å¦‚æ„"
        ];

        // Scene Objects References (for updates)
        let sunLight, moonLight, ambientLight;
        let cityWindowsMat, cityStreetLightsMat, towerGlassMat, starsPoints;

        // Audio Context for Fireworks Sound
        let audioCtx;

        // Fireworks & Particles
        let fireworks = [];
        let particleTexture; // Texture for round particles
        let handParticle; // The glow in the hand

        // Taipei 101 Group
        let towerGroup;

        // --- 1. Load Resources (AI Model) First ---
        async function loadResources() {
            try {
                // Init Copyright
                initCopyrightProtection();

                // Setup 3D Scene immediately so background isn't empty
                setupThreeJS();
                particleTexture = getParticleTexture();
                createTaipei101();
                createCity(); // Add surrounding city
                createStars();
                
                // Load AI Model
                await setupGestureRecognizer();
                
                // Ready to Start
                document.getElementById('loading-text').style.display = 'none';
                const startBtn = document.getElementById('start-btn');
                startBtn.style.display = 'block';
                
                // Slider Event
                speedSlider.addEventListener('input', (e) => {
                    // Only update speed if not in finale mode
                    if(!isFinaleMode) timeSpeed = parseFloat(e.target.value);
                });

                // Finale Button Listener
                document.getElementById('finale-btn').addEventListener('click', startFinaleMode);
                
                // Add Click Listener
                startBtn.addEventListener('click', startExperience);

            } catch (err) {
                console.error(err);
                showError("è¼‰å…¥å¤±æ•—: " + err.message);
            }
        }

        // --- 2. User Clicks Start -> Request Permissions ---
        async function startExperience() {
            const overlay = document.getElementById('overlay-screen');
            const startBtn = document.getElementById('start-btn');
            
            startBtn.innerText = "å•Ÿå‹•ä¸­...";
            startBtn.disabled = true;

            try {
                // Initialize Audio Context on user interaction
                try {
                    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                    if(audioCtx.state === 'suspended') {
                        await audioCtx.resume();
                    }
                } catch(e) { console.warn("Web Audio API not supported"); }

                // Request Webcam
                await setupWebcam();

                // Setup Speech
                setupSpeech();

                // Start Animation Loop
                overlay.style.display = 'none'; // Hide overlay
                document.getElementById('instructions').style.display = 'block';
                document.getElementById('time-controls').style.display = 'block'; // Show time controls
                document.getElementById('finale-btn').style.display = 'flex'; // Show finale button
                animate();

            } catch (err) {
                console.error("Permission Error:", err);
                startBtn.innerText = "é‡è©¦";
                startBtn.disabled = false;
                
                if (err.name === 'NotAllowedError' || err.name === 'PermissionDeniedError') {
                    showError("âš ï¸ ç„¡æ³•å–å¾—æ¬Šé™<br>è«‹é»æ“Šç¶²å€åˆ—å·¦å´çš„è¨­å®šåœ–ç¤ºï¼Œå…è¨±ã€Œæ”å½±æ©Ÿã€èˆ‡ã€Œéº¥å…‹é¢¨ã€æ¬Šé™ï¼Œç„¶å¾Œé‡æ–°æ•´ç†é é¢ã€‚");
                } else {
                    showError("å•Ÿå‹•éŒ¯èª¤: " + err.message);
                }
            }
        }

        function showError(msg) {
            const errEl = document.getElementById('error-msg');
            errEl.innerHTML = msg;
            errEl.style.display = 'block';
            document.getElementById('loading-text').style.display = 'none';
        }

        // --- Finale Mode Logic ---
        function startFinaleMode() {
            if(isFinaleMode) return;
            isFinaleMode = true;
            
            // 1. Disable Controls & UI updates
            statusMsg.innerText = "âœ¨ è·¨å¹´å€’æ•¸æ¨¡å¼å•Ÿå‹• âœ¨";
            // Hide/Dim UI
            document.getElementById('time-controls').style.opacity = '0.5';
            document.getElementById('time-controls').style.pointerEvents = 'none';
            document.getElementById('finale-btn').style.display = 'none'; // Hide button during finale
            
            // 2. Set Time to Midnight (23:59:50) approx
            gameTime = 23.99; 
            
            // 3. Countdown
            const countdownEl = document.getElementById('countdown');
            countdownEl.style.display = 'block';
            let count = 10;
            
            const timer = setInterval(() => {
                countdownEl.innerText = count;
                playFireworkSound(); // Tick sound
                count--;
                
                if (count < 0) {
                    clearInterval(timer);
                    countdownEl.style.display = 'none';
                    launchMassiveFireworks();
                }
            }, 1000);
        }

        function launchMassiveFireworks() {
            const duration = 20000; // 20 seconds of show
            const startTime = Date.now();
            
            // Loop for fireworks
            finaleInterval = setInterval(() => {
                // Random position high up
                const x = (Math.random() - 0.5) * 150;
                const y = 50 + Math.random() * 80;
                const z = (Math.random() - 0.5) * 150;
                // Random vivid colors
                const color = new THREE.Color().setHSL(Math.random(), 1.0, 0.6).getHex();
                
                createFirework(x, y, z, color);
                
                // Chance to spawn text
                if(Math.random() > 0.7) {
                    spawnFinaleText();
                }
                
                if (Date.now() - startTime > duration) {
                    endFinaleMode();
                }
            }, 200); // 5 fireworks per second
        }

        function spawnFinaleText() {
            const container = document.getElementById('wish-container');
            const el = document.createElement('div');
            el.className = 'finale-text';
            const text = finaleMessages[Math.floor(Math.random() * finaleMessages.length)];
            el.innerText = text;
            
            // Random color
            const hue = Math.floor(Math.random() * 360);
            el.style.color = `hsl(${hue}, 100%, 70%)`;
            
            // Random screen position (avoiding very edges)
            const left = 10 + Math.random() * 80;
            const top = 20 + Math.random() * 60;
            el.style.left = `${left}%`;
            el.style.top = `${top}%`;
            
            container.appendChild(el);
            
            // Remove after anim
            setTimeout(() => {
                el.remove();
            }, 4000);
        }

        function endFinaleMode() {
            clearInterval(finaleInterval);
            isFinaleMode = false;
            
            statusMsg.innerText = "ç­‰å¾…æ‰‹å‹¢...";
            document.getElementById('time-controls').style.opacity = '1';
            document.getElementById('time-controls').style.pointerEvents = 'auto';
            document.getElementById('finale-btn').style.display = 'flex';
            
            // Restore time speed from slider
            timeSpeed = parseFloat(speedSlider.value);
        }

        // --- Helper: Create a glowing dot texture ---
        function getParticleTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 32;
            canvas.height = 32;
            const context = canvas.getContext('2d');
            
            // Radial gradient for soft glow
            const gradient = context.createRadialGradient(16, 16, 0, 16, 16, 16);
            gradient.addColorStop(0, 'rgba(255,255,255,1)');       // Center white
            gradient.addColorStop(0.2, 'rgba(255,255,255,0.8)');   // Inner glow
            gradient.addColorStop(0.5, 'rgba(255,255,255,0.2)');   // Outer glow
            gradient.addColorStop(1, 'rgba(0,0,0,0)');            // Transparent edge
            
            context.fillStyle = gradient;
            context.fillRect(0, 0, 32, 32);
            
            const texture = new THREE.CanvasTexture(canvas);
            return texture;
        }

        // --- Helper: Generate Window Texture for Buildings ---
        function getWindowTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            // Background: Dark building
            ctx.fillStyle = '#000'; ctx.fillRect(0,0,64,64);
            
            // Random lit windows (Yellow/Warm)
            ctx.fillStyle = '#ffecaa'; 
            for(let i=0; i<32; i++) {
                if(Math.random() > 0.4) {
                    const x = Math.floor(Math.random()*8)*8;
                    const y = Math.floor(Math.random()*16)*4;
                    ctx.fillRect(x+1, y+1, 5, 2); // Window shape
                }
            }
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.magFilter = THREE.NearestFilter; // Pixel art style
            return texture;
        }

        // --- Three.js Setup ---
        function setupThreeJS() {
            const container = document.getElementById('canvas-container');
            
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000); // Start black
            scene.fog = new THREE.FogExp2(0x101015, 0.003); 

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 40, 160);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.toneMapping = THREE.ReinhardToneMapping;
            container.appendChild(renderer.domElement);

            // Controls
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.autoRotate = false;
            controls.maxPolarAngle = Math.PI / 2 - 0.05; 
            controls.minDistance = MIN_DISTANCE;
            controls.maxDistance = MAX_DISTANCE;
            controls.enableZoom = false; 
            controls.target.set(0, 40, 0);

            // Lighting Setup for Day/Night
            ambientLight = new THREE.AmbientLight(0x222233, 0.5); 
            scene.add(ambientLight);

            // Sun (Directional)
            sunLight = new THREE.DirectionalLight(0xffffee, 0); // Start off
            sunLight.position.set(100, 100, 50);
            scene.add(sunLight);

            // Moon (Directional - bluish)
            moonLight = new THREE.DirectionalLight(0xaaccff, 0.5); 
            moonLight.position.set(-50, 100, -50);
            scene.add(moonLight);

            // Ground
            const planeGeo = new THREE.PlaneGeometry(800, 800);
            const planeMat = new THREE.MeshStandardMaterial({ 
                color: 0x1a1a1a, 
                roughness: 0.8, 
                metalness: 0.2 
            });
            const plane = new THREE.Mesh(planeGeo, planeMat);
            plane.rotation.x = -Math.PI / 2;
            scene.add(plane);

            // Hand Tracker Particle
            const sphereGeo = new THREE.SphereGeometry(1, 16, 16);
            const sphereMat = new THREE.MeshBasicMaterial({ color: 0xffaa00 });
            handParticle = new THREE.Mesh(sphereGeo, sphereMat);
            handParticle.visible = false;
            scene.add(handParticle);

            // Resize handler
            window.addEventListener('resize', onWindowResize);
        }

        // --- Day/Night Cycle Logic ---
        function updateDayNightCycle(deltaTime) {
            // Check Finale Mode FIRST
            if(isFinaleMode) {
                // Force Night look instantly
                scene.background.setHex(0x050510);
                scene.fog.color.setHex(0x050510);
                sunLight.intensity = 0;
                moonLight.intensity = 0.8;
                ambientLight.intensity = 0.2;
                
                if(cityWindowsMat) cityWindowsMat.emissiveIntensity = 0.8;
                if(cityStreetLightsMat) cityStreetLightsMat.color.setHex(0xffddaa);
                if(towerGlassMat) towerGlassMat.emissiveIntensity = 1.0;
                if(starsPoints) starsPoints.material.opacity = 1.0;
                return; // Skip normal time update
            }

            // Update time
            // timeSpeed of 1 => 1 hour per 5 seconds roughly? Let's say 1 real sec = X game minutes
            // Let's make speed=1 be slow, speed=10 be fast.
            gameTime += (deltaTime * timeSpeed * 0.5); 
            if (gameTime >= 24) gameTime = 0;

            // Format Display
            const h = Math.floor(gameTime);
            const m = Math.floor((gameTime - h) * 60);
            timeDisplay.innerText = `ç›®å‰æ™‚é–“: ${h.toString().padStart(2,'0')}:${m.toString().padStart(2,'0')}`;

            // --- Interpolation Factors ---
            // Day: 6-18, Night: 18-6
            // Twilight: 5-7, 17-19
            
            let isNight = false;
            let sunIntensity = 0;
            let moonIntensity = 0;
            let skyColor = new THREE.Color(0x000000);
            let fogColor = new THREE.Color(0x000000);
            let cityLightsOn = false;

            if (gameTime >= 6 && gameTime < 18) {
                // DAY TIME
                isNight = false;
                
                // Sun ramp up/down
                if (gameTime < 7) { // Sunrise 6-7
                    const t = gameTime - 6;
                    sunIntensity = t;
                    moonIntensity = 0.5 * (1-t);
                    skyColor.lerpColors(new THREE.Color(0x050510), new THREE.Color(0x87CEEB), t); // Dark to Blue
                } else if (gameTime > 17) { // Sunset 17-18
                    const t = gameTime - 17;
                    sunIntensity = 1 - t;
                    moonIntensity = 0.5 * t;
                    skyColor.lerpColors(new THREE.Color(0x87CEEB), new THREE.Color(0xff4500), t); // Blue to Orange
                } else {
                    // Mid day
                    sunIntensity = 1;
                    moonIntensity = 0;
                    skyColor.setHex(0x87CEEB); // Sky Blue
                }
            } else {
                // NIGHT TIME
                isNight = true;
                sunIntensity = 0;
                
                if (gameTime >= 18 && gameTime < 19) { // Dusk 18-19
                    const t = gameTime - 18;
                    moonIntensity = 0.5 * t;
                    skyColor.lerpColors(new THREE.Color(0xff4500), new THREE.Color(0x050510), t); // Orange to Dark
                } else if (gameTime >= 5 && gameTime < 6) { // Dawn 5-6
                    const t = gameTime - 5;
                    moonIntensity = 0.5 * (1-t);
                    skyColor.lerpColors(new THREE.Color(0x050510), new THREE.Color(0x101030), t);
                } else {
                    // Deep Night
                    moonIntensity = 0.5;
                    skyColor.setHex(0x050510);
                }
                
                cityLightsOn = true;
            }

            // --- Apply Changes ---
            scene.background = skyColor;
            scene.fog.color.copy(skyColor).multiplyScalar(0.5); // Fog matches sky somewhat
            
            sunLight.intensity = sunIntensity * 1.5;
            moonLight.intensity = moonIntensity;
            ambientLight.intensity = 0.2 + sunIntensity * 0.6; // Brighter ambient in day

            // Rotate celestial bodies
            const sunAngle = ((gameTime - 6) / 24) * Math.PI * 2; // 0 at 6am (Sunrise)
            sunLight.position.set(Math.cos(sunAngle)*100, Math.sin(sunAngle)*100, 50);

            // City Lights (Windows)
            if (cityWindowsMat) {
                // Flicker or just turn on at night
                // Lerp emissive intensity
                const targetEmit = cityLightsOn ? 0.8 : 0.0;
                cityWindowsMat.emissiveIntensity += (targetEmit - cityWindowsMat.emissiveIntensity) * 0.05;
            }

            // Street Lights
            if (cityStreetLightsMat) {
                const targetColor = cityLightsOn ? new THREE.Color(0xffddaa) : new THREE.Color(0x222222);
                cityStreetLightsMat.color.lerp(targetColor, 0.05);
            }
            
            // Tower Glass (101 Lights)
            if (towerGlassMat) {
                const targetEmit = cityLightsOn ? 1.0 : 0.0; // Off in day
                towerGlassMat.emissiveIntensity += (targetEmit - towerGlassMat.emissiveIntensity) * 0.05;
            }

            // Stars (Opacity)
            if (starsPoints) {
                const targetOp = isNight ? 1.0 : 0.0;
                starsPoints.material.opacity += (targetOp - starsPoints.material.opacity) * 0.05;
            }
        }

        // --- Procedural City Generator ---
        function createCity() {
            const cityGroup = new THREE.Group();
            
            const buildingGeo = new THREE.BoxGeometry(1, 1, 1);
            const windowTex = getWindowTexture();
            
            // Store reference for update
            cityWindowsMat = new THREE.MeshStandardMaterial({
                color: 0x222222,
                map: windowTex,
                roughness: 0.2,
                emissive: 0xffaa00,
                emissiveMap: windowTex,
                emissiveIntensity: 0.8
            });
            
            const matDark = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.5 });
            const matGlass = new THREE.MeshStandardMaterial({ color: 0x223344, roughness: 0.1, metalness: 0.6 });

            // Generate Grid
            const range = 250;
            const blockSize = 30;
            
            for (let x = -range; x <= range; x += blockSize) {
                for (let z = -range; z <= range; z += blockSize) {
                    const dist = Math.sqrt(x*x + z*z);
                    if (dist < 45) continue; 
                    
                    if (Math.random() > 0.2) {
                        const height = 15 + Math.random() * 50; 
                        const width = 10 + Math.random() * 15;
                        const depth = 10 + Math.random() * 15;

                        const mesh = new THREE.Mesh(buildingGeo, Math.random()>0.3 ? cityWindowsMat : matGlass);
                        mesh.position.set(x + (Math.random()-0.5)*5, height/2, z + (Math.random()-0.5)*5);
                        mesh.scale.set(width, height, depth);
                        cityGroup.add(mesh);
                        
                        const roof = new THREE.Mesh(buildingGeo, matDark);
                        roof.position.set(mesh.position.x, height + 1, mesh.position.z);
                        roof.scale.set(width*0.8, 2, depth*0.8);
                        cityGroup.add(roof);
                    }
                }
            }

            // Street Props
            const treeGroup = new THREE.Group();
            const trunkGeo = new THREE.CylinderGeometry(0.5, 0.7, 3, 5);
            const trunkMat = new THREE.MeshStandardMaterial({ color: 0x443322 });
            const leavesGeo = new THREE.IcosahedronGeometry(2.5, 0);
            const leavesMat = new THREE.MeshStandardMaterial({ color: 0x225522, roughness: 0.9 });
            
            const poleGeo = new THREE.CylinderGeometry(0.2, 0.2, 8);
            const poleMat = new THREE.MeshStandardMaterial({ color: 0x333333 });
            const lightGeo = new THREE.SphereGeometry(0.8);
            
            // Store reference
            cityStreetLightsMat = new THREE.MeshBasicMaterial({ color: 0xffddaa });

            for (let i = 0; i < 150; i++) {
                const r = 50 + Math.random() * 200;
                const theta = Math.random() * Math.PI * 2;
                const px = r * Math.cos(theta);
                const pz = r * Math.sin(theta);

                if (Math.random() > 0.4) {
                    const trunk = new THREE.Mesh(trunkGeo, trunkMat);
                    trunk.position.set(px, 1.5, pz);
                    treeGroup.add(trunk);
                    
                    const leaves = new THREE.Mesh(leavesGeo, leavesMat);
                    leaves.position.set(px, 4, pz);
                    treeGroup.add(leaves);
                } else {
                    const pole = new THREE.Mesh(poleGeo, poleMat);
                    pole.position.set(px, 4, pz);
                    treeGroup.add(pole);

                    const light = new THREE.Mesh(lightGeo, cityStreetLightsMat);
                    light.position.set(px, 8, pz);
                    treeGroup.add(light);
                }
            }
            
            scene.add(cityGroup);
            scene.add(treeGroup);
        }

        // --- Procedural Taipei 101 ---
        function createTaipei101() {
            towerGroup = new THREE.Group();

            // Store reference
            towerGlassMat = new THREE.MeshPhysicalMaterial({
                color: 0x00aadd,
                metalness: 0.2,
                roughness: 0.1,
                transmission: 0.6,
                thickness: 2,
                emissive: 0x004466,
                emissiveIntensity: 1.0 
            });

            const goldMaterial = new THREE.MeshStandardMaterial({
                color: 0xffd700,
                metalness: 0.8,
                roughness: 0.2
            });

            const baseGeo = new THREE.BoxGeometry(20, 15, 20);
            const base = new THREE.Mesh(baseGeo, towerGlassMat);
            base.position.y = 7.5;
            towerGroup.add(base);

            const segmentCount = 8;
            const startY = 15;
            const segmentHeight = 8;
            
            for(let i=0; i<segmentCount; i++) {
                const yPos = startY + i * segmentHeight;
                const segmentGeo = new THREE.CylinderGeometry(11 - (i*0.2), 9 - (i*0.2), segmentHeight, 4);
                segmentGeo.rotateY(Math.PI/4); 
                const segment = new THREE.Mesh(segmentGeo, towerGlassMat);
                segment.position.y = yPos + segmentHeight/2;
                towerGroup.add(segment);

                if (i < segmentCount) {
                    for(let c=0; c<4; c++) {
                        const cornerGeo = new THREE.BoxGeometry(1,1,1);
                        const corner = new THREE.Mesh(cornerGeo, goldMaterial);
                        const angle = (Math.PI/2) * c;
                        const radius = 8 - (i*0.2);
                        corner.position.set(Math.cos(angle)*radius*1.2, yPos + segmentHeight, Math.sin(angle)*radius*1.2);
                        towerGroup.add(corner);
                    }
                }
            }

            const spireHeight = 15;
            const spireGeo = new THREE.CylinderGeometry(0.5, 3, spireHeight, 8);
            const spire = new THREE.Mesh(spireGeo, towerGlassMat);
            spire.position.y = startY + (segmentCount * segmentHeight) + spireHeight/2;
            towerGroup.add(spire);

            scene.add(towerGroup);
        }

        function createStars() {
            const starGeo = new THREE.BufferGeometry();
            const starCount = 1000;
            const posArray = new Float32Array(starCount * 3);
            for(let i=0; i<starCount*3; i++) {
                posArray[i] = (Math.random() - 0.5) * 500; // Spread out
            }
            starGeo.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
            
            const starMat = new THREE.PointsMaterial({
                size: 1.5, 
                color: 0xffffff, 
                map: particleTexture, 
                transparent: true,
                opacity: 1.0, // Start visible (it's night)
                alphaTest: 0.1
            });
            starsPoints = new THREE.Points(starGeo, starMat);
            starsPoints.position.y = 100;
            scene.add(starsPoints);
        }

        // --- MediaPipe Setup ---
        async function setupGestureRecognizer() {
            const vision = await FilesetResolver.forVisionTasks(
                "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm"
            );
            gestureRecognizer = await GestureRecognizer.createFromOptions(vision, {
                baseOptions: {
                    modelAssetPath: "https://storage.googleapis.com/mediapipe-models/gesture_recognizer/gesture_recognizer/float16/1/gesture_recognizer.task",
                    delegate: "GPU"
                },
                runningMode: "VIDEO",
                numHands: 1 
            });
            drawingUtils = new DrawingUtils(canvasCtx);
        }

        async function setupWebcam() {
            const constraints = { video: { width: WEBCAM_WIDTH, height: WEBCAM_HEIGHT } };
            const stream = await navigator.mediaDevices.getUserMedia(constraints);
            video.srcObject = stream;
            return new Promise((resolve) => {
                video.onloadeddata = () => {
                    webcamRunning = true;
                    resolve();
                };
            });
        }

        // --- Speech Recognition ---
        function setupSpeech() {
            if ('webkitSpeechRecognition' in window) {
                recognition = new webkitSpeechRecognition();
                recognition.continuous = false;
                recognition.interimResults = false;
                recognition.lang = 'zh-TW';

                recognition.onstart = () => {
                    statusMsg.innerText = "ğŸ¤ è«‹èªªå‡ºä½ çš„é¡˜æœ›ï¼";
                    speechBubble.innerText = "è«‹èªªå‡ºä½ çš„é¡˜æœ›...";
                    speechBubble.style.display = 'block';
                };

                recognition.onresult = (event) => {
                    const transcript = event.results[0][0].transcript;
                    showWish(transcript);
                    speechBubble.style.display = 'none'; // Hide bubble after result
                };

                recognition.onerror = (event) => {
                    console.error("Speech error", event);
                    statusMsg.innerText = "èªéŸ³è¾¨è­˜éŒ¯èª¤ï¼Œè«‹é‡è©¦";
                    speechBubble.style.display = 'none';
                    resetWishState();
                };
                
                recognition.onend = () => {
                   if(isMakingWish) {
                       setTimeout(resetWishState, 5000); 
                   }
                };

            } else {
                console.warn("Speech API not supported");
            }
        }

        function triggerWishSequence() {
            if (isMakingWish) return;
            isMakingWish = true;
            
            const countdownEl = document.getElementById('countdown');
            countdownEl.style.display = 'block';
            let count = 3;
            
            statusMsg.innerText = "è¨±é¡˜å€’æ•¸ä¸­...";
            speechBubble.innerText = "3...";
            speechBubble.style.display = 'block';
            
            const timer = setInterval(() => {
                countdownEl.innerText = count;
                speechBubble.innerText = count + "...";
                createFirework(0, 40 + (3-count)*10, 0, 0xffd700); // Celebration fireworks
                count--;
                if (count < 0) {
                    clearInterval(timer);
                    countdownEl.style.display = 'none';
                    if(recognition) {
                        try {
                            recognition.start();
                        } catch(e) {
                            console.log("Recognition already started or error", e);
                        }
                    } else {
                        showWish("æ–°å¹´å¿«æ¨‚!"); // Fallback
                        speechBubble.style.display = 'none';
                    }
                }
            }, 1000);
        }

        function showWish(text) {
            const container = document.getElementById('wish-container');
            const el = document.createElement('div');
            el.className = 'wish-text float-anim';
            el.innerText = text + " âœ¨";
            
            const rX = (Math.random() - 0.5) * 40;
            const rY = 30 + Math.random() * 20;
            
            el.style.left = `50%`;
            el.style.top = `40%`;
            el.style.transform = `translate(-50%, -50%)`;
            
            container.appendChild(el);
            
            for(let i=0; i<5; i++) {
                setTimeout(() => {
                    createFirework((Math.random()-0.5)*40, 40+Math.random()*40, (Math.random()-0.5)*40);
                }, i * 300);
            }
        }

        function resetWishState() {
            isMakingWish = false;
            statusMsg.innerText = "ç­‰å¾…æ‰‹å‹¢...";
            speechBubble.style.display = 'none';
        }

        // --- Logic Loop ---
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            const deltaTime = clock.getDelta();
            
            // 1. Update Day/Night
            updateDayNightCycle(deltaTime);

            // 2. Predict Webcam
            if (webcamRunning && gestureRecognizer) {
                predictWebcam();
            }

            // 3. Update Scene
            controls.update();
            updateFireworks();
            
            // Animate 101 glow pulse ONLY if it's night (checked via intensity)
            // But we already handle day/night intensity in updateDayNightCycle
            // So we just add pulse on top if intensity > 0.5 roughly
            if(towerGroup && towerGlassMat.emissiveIntensity > 0.3) {
               const time = Date.now() * 0.001;
               // Add a subtle pulse on top of the base intensity set by day/night cycle
               // We need to be careful not to override the day/night logic. 
               // Actually, day/night sets a 'target' base. Let's just oscillate slightly around current value?
               // Or simpler: The day/night logic sets the main value. We don't need extra pulse if it complicates things.
               // Let's keep the pulse but modulate it by overall intensity.
               // towerGlassMat.emissiveIntensity += Math.sin(time) * 0.1 * towerGlassMat.emissiveIntensity; 
               // (Simplified: let day/night control it mostly, maybe flicker slightly)
            }

            renderer.render(scene, camera);
        }

        function get3DHandPosition(x, y) {
            const vec = new THREE.Vector3();
            const pos = new THREE.Vector3();
            
            vec.set(
                (1 - x) * 2 - 1, 
                - (y * 2 - 1),
                0.5
            );
            
            vec.unproject(camera);
            vec.sub(camera.position).normalize();
            
            const distance = 40; 
            pos.copy(camera.position).add(vec.multiplyScalar(distance));
            return pos;
        }

        // --- Sound Synthesis ---
        function playFireworkSound() {
            if (!audioCtx) return;
            if (audioCtx.state === 'suspended') {
                audioCtx.resume().catch(e => console.log("Audio resume failed", e));
            }

            const t = audioCtx.currentTime;
            
            // Explosion
            const bufferSize = audioCtx.sampleRate * 2; 
            const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) {
                data[i] = Math.random() * 2 - 1;
            }

            const noise = audioCtx.createBufferSource();
            noise.buffer = buffer;
            const noiseFilter = audioCtx.createBiquadFilter();
            noiseFilter.type = 'lowpass';
            noiseFilter.frequency.setValueAtTime(1000, t);
            noiseFilter.frequency.exponentialRampToValueAtTime(100, t + 0.5);
            const noiseGain = audioCtx.createGain();
            noiseGain.gain.setValueAtTime(1, t);
            noiseGain.gain.exponentialRampToValueAtTime(0.01, t + 0.5);

            noise.connect(noiseFilter);
            noiseFilter.connect(noiseGain);
            noiseGain.connect(audioCtx.destination);
            noise.start(t);
            noise.stop(t + 0.5);

            // Thud
            const osc = audioCtx.createOscillator();
            osc.type = 'sine';
            osc.frequency.setValueAtTime(150, t);
            osc.frequency.exponentialRampToValueAtTime(40, t + 0.5);
            const oscGain = audioCtx.createGain();
            oscGain.gain.setValueAtTime(1, t);
            oscGain.gain.exponentialRampToValueAtTime(0.01, t + 0.5);

            osc.connect(oscGain);
            oscGain.connect(audioCtx.destination);
            osc.start(t);
            osc.stop(t + 0.5);
        }

        let previousCategoryName = "";
        let handClosed = false;
        let handPos3D = new THREE.Vector3();

        function dist(a, b) {
            return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2));
        }

        async function predictWebcam() {
            // CHECK FINALE MODE FIRST - DISABLE GESTURES IF ACTIVE
            if(isFinaleMode) {
                canvasCtx.clearRect(0, 0, outputCanvas.width, outputCanvas.height);
                handParticle.visible = false;
                return;
            }

            let nowInMs = Date.now();
            const results = gestureRecognizer.recognizeForVideo(video, nowInMs);

            // Clear canvas
            canvasCtx.clearRect(0, 0, outputCanvas.width, outputCanvas.height);

            if (results.landmarks && results.landmarks.length > 0) {
                // Draw skeleton
                for (const landmarks of results.landmarks) {
                    drawingUtils.drawConnectors(landmarks, GestureRecognizer.HAND_CONNECTIONS, {
                        color: "#00FF00",
                        lineWidth: 3
                    });
                    drawingUtils.drawLandmarks(landmarks, {
                        color: "#FF0000",
                        lineWidth: 1,
                        radius: 3
                    });
                }

                if (results.gestures.length > 0) {
                    const gesture = results.gestures[0][0];
                    const categoryName = gesture.categoryName;
                    const landmarks = results.landmarks[0]; 

                    // Calculate center
                    const palmX = (landmarks[0].x + landmarks[9].x) / 2;
                    const palmY = (landmarks[0].y + landmarks[9].y) / 2;
                    
                    handPos3D = get3DHandPosition(palmX, palmY);
                    handParticle.position.copy(handPos3D);
                    handParticle.visible = true;

                    // --- Geometry Calculations for Zoom & Rotate ---
                    const handSize = dist(landmarks[0], landmarks[9]);
                    const pinchDistance = dist(landmarks[4], landmarks[8]);
                    const pinchRatio = pinchDistance / handSize;
                    
                    const idxDx = landmarks[8].x - landmarks[5].x; 
                    const idxDy = landmarks[8].y - landmarks[5].y; 
                    
                    let isZooming = false;
                    let isRotating = false;

                    // --- GESTURE LOGIC START ---

                    if (categoryName === "Victory") {
                        handParticle.material.color.setHex(0xffff00);
                        statusMsg.innerText = "âœŒï¸ æº–å‚™è¨±é¡˜...";
                        handClosed = false;
                        triggerWishSequence();
                    }
                    else {
                        const currentDist = camera.position.distanceTo(controls.target);
                        
                        // Zoom In
                        if (pinchRatio < 0.15) {
                            if (currentDist > MIN_DISTANCE) {
                                statusMsg.innerText = "ğŸ‘Œ è¦–è§’æ‹‰è¿‘ (Zoom In)";
                                handParticle.material.color.setHex(0x00ffff);
                                const direction = new THREE.Vector3();
                                camera.getWorldDirection(direction);
                                camera.position.addScaledVector(direction, 0.5);
                                isZooming = true;
                            } else {
                                statusMsg.innerText = "ğŸš« å·²é”æœ€è¿‘è·é›¢";
                            }
                        } 
                        // Zoom Out
                        else if (pinchRatio > 0.8 && categoryName !== "Open_Palm") {
                            if (currentDist < MAX_DISTANCE) {
                                statusMsg.innerText = "ğŸ‘ è¦–è§’æ‹‰é  (Zoom Out)";
                                handParticle.material.color.setHex(0x0000ff);
                                const direction = new THREE.Vector3();
                                camera.getWorldDirection(direction);
                                camera.position.addScaledVector(direction, -0.5);
                                isZooming = true;
                            } else {
                                statusMsg.innerText = "ğŸš« å·²é”æœ€é è·é›¢";
                            }
                        }

                        if (!isZooming) {
                            const indexLen = dist(landmarks[5], landmarks[8]);
                            const isIndexExtended = indexLen > handSize * 0.5;
                            
                            if (isIndexExtended && categoryName !== "Open_Palm" && categoryName !== "Closed_Fist") {
                                const sensitivity = 0.03;
                                let directionMsg = "";
                                let hasMovement = false;

                                // Horizontal
                                if (idxDx < -0.05) { // Left
                                    directionMsg += "ğŸ‘ˆ";
                                    controls.autoRotate = false;
                                    camera.position.applyAxisAngle(new THREE.Vector3(0,1,0), sensitivity); 
                                    hasMovement = true;
                                } else if (idxDx > 0.05) { // Right
                                    directionMsg += "ğŸ‘‰";
                                    controls.autoRotate = false;
                                    camera.position.applyAxisAngle(new THREE.Vector3(0,1,0), -sensitivity);
                                    hasMovement = true;
                                }

                                // Vertical
                                if (idxDy < -0.05) { // Up
                                    directionMsg += "ğŸ‘†";
                                    camera.position.y += 0.5;
                                    hasMovement = true;
                                } else if (idxDy > 0.05) { // Down
                                    directionMsg += "ğŸ‘‡";
                                    camera.position.y -= 0.5;
                                    if(camera.position.y < 5) camera.position.y = 5; 
                                    hasMovement = true;
                                }

                                if (hasMovement) {
                                    statusMsg.innerText = directionMsg + " èª¿æ•´è¦–è§’";
                                    camera.lookAt(0, 40, 0); 
                                    isRotating = true;
                                }
                            }
                            
                            if (!isRotating) {
                                if (categoryName === "Closed_Fist") {
                                    statusMsg.innerText = "âœŠ é›†æ°£ä¸­...";
                                    handParticle.material.color.setHex(0xff0000);
                                    handClosed = true; 
                                    handParticle.scale.setScalar(1.5 + Math.sin(nowInMs * 0.02) * 0.5);
                                } 
                                else if (categoryName === "Open_Palm") {
                                    statusMsg.innerText = "ğŸ–ï¸ æ–½æ”¾ç…™ç«ï¼";
                                    handParticle.material.color.setHex(0xffffff);
                                    handParticle.scale.setScalar(1);

                                    if (handClosed) {
                                        createFirework(handPos3D.x, handPos3D.y, handPos3D.z);
                                        playFireworkSound(); 
                                        handClosed = false; 
                                    }
                                } else {
                                    statusMsg.innerText = "ç­‰å¾…æ‰‹å‹¢...";
                                    handParticle.scale.setScalar(1);
                                }
                            }
                        }
                    }

                    previousCategoryName = categoryName;
                }
            } else {
                handParticle.visible = false;
            }
        }

        // --- Fireworks System (Updated for Fine Particles & Glow) ---
        function createFirework(x, y, z, forceColor = null) {
            const particleCount = 400 + Math.random() * 200;
            const geometry = new THREE.BufferGeometry();
            const positions = [];
            const velocities = [];
            const colors = [];

            const baseColor = new THREE.Color();
            if (forceColor) {
                baseColor.setHex(forceColor);
            } else {
                baseColor.setHSL(Math.random(), 1.0, 0.6); 
            }

            for (let i = 0; i < particleCount; i++) {
                positions.push(x, y, z);
                
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos((Math.random() * 2) - 1);
                const speed = 0.2 + Math.random() * 2.5; 
                
                velocities.push(
                    speed * Math.sin(phi) * Math.cos(theta),
                    speed * Math.sin(phi) * Math.sin(theta),
                    speed * Math.cos(phi)
                );

                const pColor = baseColor.clone();
                pColor.offsetHSL(0, 0, (Math.random() - 0.5) * 0.4); 
                colors.push(pColor.r, pColor.g, pColor.b);
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

            const material = new THREE.PointsMaterial({ 
                size: 2.5, 
                map: particleTexture, 
                vertexColors: true, 
                blending: THREE.AdditiveBlending, 
                depthWrite: false,
                transparent: true,
                opacity: 1.0
            });

            const points = new THREE.Points(geometry, material);
            scene.add(points);

            if(forceColor) playFireworkSound();

            fireworks.push({
                mesh: points,
                velocities: velocities,
                age: 0,
                maxAge: 80 + Math.random() * 40
            });
        }

        function updateFireworks() {
            for (let i = fireworks.length - 1; i >= 0; i--) {
                const fw = fireworks[i];
                fw.age++;

                const positions = fw.mesh.geometry.attributes.position.array;

                for (let j = 0; j < fw.velocities.length / 3; j++) {
                    positions[j * 3] += fw.velocities[j * 3];
                    positions[j * 3 + 1] += fw.velocities[j * 3 + 1];
                    positions[j * 3 + 2] += fw.velocities[j * 3 + 2];
                    fw.velocities[j * 3 + 1] -= 0.015; 
                    fw.velocities[j * 3] *= 0.96;
                    fw.velocities[j * 3 + 1] *= 0.96;
                    fw.velocities[j * 3 + 2] *= 0.96;
                }

                fw.mesh.geometry.attributes.position.needsUpdate = true;
                
                const lifeRatio = fw.age / fw.maxAge;
                fw.mesh.material.opacity = 1 - Math.pow(lifeRatio, 3);
                fw.mesh.material.size = Math.max(0.1, 2.5 * (1 - lifeRatio * 0.5));

                if (fw.age >= fw.maxAge) {
                    scene.remove(fw.mesh);
                    fw.mesh.geometry.dispose();
                    fw.mesh.material.dispose();
                    fireworks.splice(i, 1);
                }
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Run
        loadResources();

    </script>
</body>
</html>